{
  "className": "qx.Promise",
  "packageName": "qx",
  "name": "Promise",
  "superClass": "qx.core.Object",
  "interfaces": [],
  "mixins": [],
  "clazz": {
    "location": {
      "start": {
        "line": 59,
        "column": 0
      },
      "end": {
        "line": 885,
        "column": 3
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "***********************************************************************\n\nqooxdoo - the new era of web development\n\nhttp://qooxdoo.org\n\nCopyright:\n2016 Zenesis Limited, http://www.zenesis.com\nBluebirdJS Copyright (c) 2013-2016 Petka Antonov http://bluebirdjs.com/\n\nLicense:\nMIT: https://opensource.org/licenses/MIT\nSee the LICENSE file in the project's top-level directory for details.\n\nAuthors:\nJohn Spackman (john.spackman@zenesis.com)\n\n***********************************************************************"
        },
        {
          "name": "@description",
          "body": "This class adds Promise/A+ support to Qooxdoo, as specified at\nhttps://github.com/promises-aplus/promises-spec and using the Bluebird Promise\nlibrary (http://bluebirdjs.com/) to implement it.  The official Promise/A+ API)\nis mirrored exactly, and a number of extension methods are added with the BluebirdJS\nAPI for inspiration (many/most of the extension functions are taken verbatim).\n\nThere are two ways to bind a 'this' value to callbacks - the first is to\nappend a context method to methods like then(), and the second is to specify\nthe context as the second parameter to the constructor and all callbacks will\nbe bound to that value.\n\nFor example:\n\n<pre class=\"javascript\">\nvar promise = new qx.Promise(myAsyncFunction, this);\npromise.then(function() {\n// 'this' is preserved from the outer scope\n});\n\n// ... is the same as: ...\nvar promise = new qx.Promise(myAsyncFunction);\npromise.then(function() {\n// 'this' is preserved from the outer scope\n}, this);\n</pre>\n\nIf you have an existing qx.Promise and want to bind all callbacks, use the\nbind() method - but note that it returns a new promise:\n\n<pre class=\"javascript\">\nvar promise = someMethodThatReturnsAPromise();\nvar boundPromise = promise.bind(this);\nboundPromise.then(function() {\n// 'this' is preserved from the outer scope\n}, this);\n</pre>"
        }
      ]
    }
  },
  "type": "class",
  "construct": {
    "location": {
      "start": {
        "line": 73,
        "column": 2
      },
      "end": {
        "line": 91,
        "column": 3
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "Constructor.\n\nThe promise function is called with two parameters, functions which are to be called\nwhen the promise is fulfilled or rejected respectively.  If you do not provide any\nparameters, the promise can be externally resolved or rejected by calling the\n<code>resolve()</code> or <code>reject()</code> methods."
        }
      ],
      "@param": [
        {
          "name": "@param",
          "body": "fn {Function} the promise function called with <code>(resolve, reject)</code>",
          "paramName": "fn",
          "description": " the promise function called with <code>(resolve, reject)</code>",
          "type": "Function"
        },
        {
          "name": "@param",
          "body": "context {Object?} optional context for all callbacks",
          "paramName": "context",
          "description": " optional context for all callbacks",
          "optional": true,
          "type": "Object"
        }
      ]
    }
  },
  "destruct": {
    "location": {
      "start": {
        "line": 96,
        "column": 2
      },
      "end": {
        "line": 99,
        "column": 3
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "Destructor"
        }
      ]
    }
  },
  "members": {
    "__p": {
      "location": {
        "start": {
          "line": 103,
          "column": 4
        },
        "end": {
          "line": 103,
          "column": 13
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "The Promise"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "__external": {
      "location": {
        "start": {
          "line": 106,
          "column": 4
        },
        "end": {
          "line": 106,
          "column": 20
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Stores data for completing the promise externally"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "then": {
      "location": {
        "start": {
          "line": 126,
          "column": 4
        },
        "end": {
          "line": 128,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "********************************************************************************\n\nPromise API methods"
          },
          {
            "name": "@description",
            "body": "Returns a promise which is determined by the functions <code>onFulfilled</code>\nand <code>onRejected</code>."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "onFulfilled {Function} called when the Promise is fulfilled. This function\nhas one argument, the fulfillment value.",
            "paramName": "onFulfilled",
            "description": " called when the Promise is fulfilled. This function\nhas one argument, the fulfillment value.",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "onRejected {Function?} called when the Promise is rejected. This function\nhas one argument, the rejection reason.",
            "paramName": "onRejected",
            "description": " called when the Promise is rejected. This function\nhas one argument, the rejection reason.",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "catch": {
      "location": {
        "start": {
          "line": 140,
          "column": 4
        },
        "end": {
          "line": 142,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Appends a rejection handler callback to the promise, and returns a new promise\nresolving to the return value of the callback if it is called, or to its original\nfulfillment value if the promise is instead fulfilled."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "onRejected {Function?} called when the Promise is rejected. This function\nhas one argument, the rejection reason.",
            "paramName": "onRejected",
            "description": " called when the Promise is rejected. This function\nhas one argument, the rejection reason.",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a qx.Promise is rejected if onRejected throws an error or\nreturns a Promise which is itself rejected; otherwise, it is resolved.",
            "type": "qx.Promise",
            "desc": " a qx.Promise is rejected if onRejected throws an error or\nreturns a Promise which is itself rejected; otherwise, it is resolved."
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "bind": {
      "location": {
        "start": {
          "line": 158,
          "column": 4
        },
        "end": {
          "line": 160,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "********************************************************************************\n\nExtension Promise methods"
          },
          {
            "name": "@description",
            "body": "Creates a new qx.Promise with the 'this' set to a different context"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "context {Object} the 'this' context for the new Promise",
            "paramName": "context",
            "description": " the 'this' context for the new Promise",
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} the new promise",
            "type": "qx.Promise",
            "desc": " the new promise"
          }
        ]
      },
      "type": "function",
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "appearsIn": [
        "qx.core.Object",
        "qx.data.MBinding"
      ]
    },
    "spread": {
      "location": {
        "start": {
          "line": 184,
          "column": 4
        },
        "end": {
          "line": 186,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Like calling <code>.then</code>, but the fulfillment value must be an array, which is flattened\nto the formal parameters of the fulfillment handler.\n\nFor example:\n<pre>\nqx.Promise.all([\nfs.readFileAsync(\"file1.txt\"),\nfs.readFileAsync(\"file2.txt\")\n]).spread(function(file1text, file2text) {\nif (file1text === file2text) {\nconsole.log(\"files are equal\");\n}\nelse {\nconsole.log(\"files are not equal\");\n}\n});\n</pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "fulfilledHandler {Function} called when the Promises are fulfilled.",
            "paramName": "fulfilledHandler",
            "description": " called when the Promises are fulfilled.",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "finally": {
      "location": {
        "start": {
          "line": 196,
          "column": 4
        },
        "end": {
          "line": 198,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Appends a handler that will be called regardless of this promise's fate. The handler\nis not allowed to modify the value of the promise"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "handler {Function?} called when the Promise is fulfilled or rejected. This function\nhas no arguments, but can return a promise",
            "paramName": "handler",
            "description": " called when the Promise is fulfilled or rejected. This function\nhas no arguments, but can return a promise",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a qx.Promise chained from this promise",
            "type": "qx.Promise",
            "desc": " a qx.Promise chained from this promise"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "cancel": {
      "location": {
        "start": {
          "line": 203,
          "column": 4
        },
        "end": {
          "line": 205,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Cancel this promise. Will not do anything if this promise is already settled."
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "all": {
      "location": {
        "start": {
          "line": 215,
          "column": 4
        },
        "end": {
          "line": 217,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.all} except that it iterates over the value of this promise, when\nit is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array),\n<code>.all</code> will return a Promise that waits for all promises in that Iterable to be\nfullfilled.  The Iterable can be a mix of values and Promises"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "race": {
      "location": {
        "start": {
          "line": 227,
          "column": 4
        },
        "end": {
          "line": 229,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.race} except that it iterates over the value of this promise, when\nit is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array),\n<code>.race</code> will return a Promise that waits until the first promise in that Iterable\nhas been fullfilled.  The Iterable can be a mix of values and Promises"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "any": {
      "location": {
        "start": {
          "line": 238,
          "column": 4
        },
        "end": {
          "line": 240,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\nit is fulfilled.  Like <code>some</code>, with 1 as count. However, if the promise fulfills,\nthe fulfillment value is not an array of 1 but the value directly."
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "some": {
      "location": {
        "start": {
          "line": 251,
          "column": 4
        },
        "end": {
          "line": 253,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\nit is fulfilled; return a promise that is fulfilled as soon as count promises are fulfilled\nin the array. The fulfillment value is an array with count values in the order they were fulfilled."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "count {Integer}"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "forEach": {
      "location": {
        "start": {
          "line": 269,
          "column": 4
        },
        "end": {
          "line": 271,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.forEach} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over the values with the given <code>iterator</code> function with the signature\n<code>(value, index, length)</code> where <code>value</code> is the resolved value. Iteration happens\nserially. If any promise is rejected the returned promise is rejected as well.\n\nResolves to the original array unmodified, this method is meant to be used for side effects. If the iterator\nfunction returns a promise or a thenable, then the result of the promise is awaited, before continuing with\nnext iteration."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "filter": {
      "location": {
        "start": {
          "line": 283,
          "column": 4
        },
        "end": {
          "line": 285,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.filter} except that it iterates over the value of this promise, when it is fulfilled;\niterates over all the values into an array and filter the array to another using the given filterer function."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n<code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n<code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "map": {
      "location": {
        "start": {
          "line": 306,
          "column": 4
        },
        "end": {
          "line": 308,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.map} except that it iterates over the value of this promise, when it is fulfilled;\niterates over all the values into an array and map the array to another using the given mapper function.\n\nPromises returned by the mapper function are awaited for and the returned promise doesn't fulfill\nuntil all mapped promises have fulfilled as well. If any promise in the array is rejected, or\nany promise returned by the mapper function is rejected, the returned promise is rejected as well.\n\nThe mapper function for a given item is called as soon as possible, that is, when the promise\nfor that item's index in the input array is fulfilled. This doesn't mean that the result array\nhas items in random order, it means that .map can be used for concurrency coordination unlike\n.all."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n<code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n<code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "mapSeries": {
      "location": {
        "start": {
          "line": 327,
          "column": 4
        },
        "end": {
          "line": 329,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.mapSeries} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over all the values into an array and iterate over the array serially,\nin-order.\n\nReturns a promise for an array that contains the values returned by the iterator function in their\nrespective positions. The iterator won't be called for an item until its previous item, and the\npromise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of\nutility but it can also be used simply as a side effect iterator similar to Array#forEach.\n\nIf any promise in the input array is rejected or any promise returned by the iterator function is\nrejected, the result will be rejected as well."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reduce": {
      "location": {
        "start": {
          "line": 353,
          "column": 4
        },
        "end": {
          "line": 355,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Same as {@link qx.Promise.reduce} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over all the values in the <code>Iterable</code> into an array and\nreduce the array to a value using the given reducer function.\n\nIf the reducer function returns a promise, then the result of the promise is awaited, before\ncontinuing with next iteration. If any promise in the array is rejected or a promise returned\nby the reducer function is rejected, the result is rejected as well.\n\nIf initialValue is undefined (or a promise that resolves to undefined) and the iterable contains\nonly 1 item, the callback will not be called and the iterable's single item is returned. If the\niterable is empty, the callback will not be called and initialValue is returned (which may be\nundefined).\n\nqx.Promise.reduce will start calling the reducer as soon as possible, this is why you might want to\nuse it over qx.Promise.all (which awaits for the entire array before you can call Array#reduce on it)."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "reducer {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "reducer",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "initialValue {Object?} optional initial value",
            "paramName": "initialValue",
            "description": " optional initial value",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "desc": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "__externalPromise": {
      "location": {
        "start": {
          "line": 360,
          "column": 4
        },
        "end": {
          "line": 362,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "External promise handler"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__getPendingExternal": {
      "location": {
        "start": {
          "line": 367,
          "column": 4
        },
        "end": {
          "line": 376,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Returns the data stored by __externalPromise, throws an exception once processed"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "resolve": {
      "location": {
        "start": {
          "line": 381,
          "column": 4
        },
        "end": {
          "line": 383,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Resolves an external promise"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reject": {
      "location": {
        "start": {
          "line": 388,
          "column": 4
        },
        "end": {
          "line": 390,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Rejects an external promise"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "_callIterableMethod": {
      "location": {
        "start": {
          "line": 405,
          "column": 4
        },
        "end": {
          "line": 411,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "********************************************************************************\n\nUtility methods"
          },
          {
            "name": "@description",
            "body": "Helper method used to call Promise methods which iterate over an array"
          }
        ]
      },
      "type": "function",
      "access": "protected"
    },
    "_callMethod": {
      "location": {
        "start": {
          "line": 416,
          "column": 4
        },
        "end": {
          "line": 419,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Helper method used to call a Promise method"
          }
        ]
      },
      "type": "function",
      "access": "protected"
    },
    "toPromise": {
      "location": {
        "start": {
          "line": 431,
          "column": 4
        },
        "end": {
          "line": 433,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Returns the actual Promise implementation.\n\nNote that Bluebird is the current implementation, and may change without\nnotice in the future; if you use this API you accept that this is a private\nimplementation detail exposed for debugging or diagnosis purposes only.  For\nthis reason, the toPromise() method is listed as deprecated starting from the\nfirst release"
          }
        ],
        "@deprecated": [
          {
            "name": "@deprecated",
            "body": "{6.0} this API method is subject to change"
          }
        ]
      },
      "type": "function",
      "access": "public"
    }
  },
  "defer": {
    "location": {
      "start": {
        "line": 879,
        "column": 2
      },
      "end": {
        "line": 884,
        "column": 3
      }
    }
  },
  "descendants": []
}