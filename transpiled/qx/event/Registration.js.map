{
  "version": 3,
  "sources": [
    "Registration.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__managers",
    "getManager",
    "target",
    "core",
    "Environment",
    "get",
    "log",
    "Logger",
    "error",
    "trace",
    "window",
    "nodeType",
    "dom",
    "Node",
    "getWindow",
    "isWindow",
    "hash",
    "$$hash",
    "ObjectRegistry",
    "toHashCode",
    "manager",
    "event",
    "Manager",
    "removeManager",
    "mgr",
    "id",
    "getWindowId",
    "addListener",
    "type",
    "listener",
    "self",
    "capture",
    "removeListener",
    "removeListenerById",
    "removeAllListeners",
    "deleteAllListeners",
    "targetKey",
    "hasListener",
    "serializeListeners",
    "createEvent",
    "clazz",
    "args",
    "arguments",
    "length",
    "undefined",
    "Error",
    "Event",
    "obj",
    "Pool",
    "getInstance",
    "getObject",
    "init",
    "apply",
    "setType",
    "dispatchEvent",
    "__fireEvent",
    "msg",
    "classname",
    "Assert",
    "assertNotUndefined",
    "assertNotNull",
    "evt",
    "fireEvent",
    "getDefaultPrevented",
    "fireEventAsync",
    "promise",
    "__fireNonBubblingEvent",
    "fireNonBubblingEvent",
    "fireNonBubblingEventAsync",
    "select",
    "Promise",
    "resolve",
    "PRIORITY_FIRST",
    "PRIORITY_NORMAL",
    "PRIORITY_LAST",
    "__handlers",
    "addHandler",
    "handler",
    "assertInterface",
    "IEventHandler",
    "push",
    "sort",
    "a",
    "b",
    "PRIORITY",
    "getHandlers",
    "__dispatchers",
    "addDispatcher",
    "dispatcher",
    "priority",
    "IEventDispatcher",
    "getDispatchers",
    "Registration"
  ],
  "mappings": "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",
  "file": "Registration.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Sebastian Werner (wpbasti)\n\n************************************************************************ */\n\n/**\n * Wrapper for browser generic event handling.\n *\n * Supported events differ from target to target. Generally the handlers\n * in {@link qx.event.handler} defines the available features.\n *\n * @require(qx.event.Manager)\n * @require(qx.dom.Node)\n * @require(qx.lang.Function)\n */\nqx.Class.define(\"qx.event.Registration\",\n{\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /**\n     * Static list of all instantiated event managers. The key is the qooxdoo\n     * hash value of the corresponding window\n     */\n    __managers : {},\n\n\n    /**\n     * Get an instance of the event manager, which can handle events for the\n     * given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {qx.event.Manager} The event manger for the target.\n     */\n    getManager : function(target)\n    {\n      if (target == null)\n      {\n        if (qx.core.Environment.get(\"qx.debug\"))\n        {\n          qx.log.Logger.error(\"qx.event.Registration.getManager(null) was called!\");\n          qx.log.Logger.trace(this);\n        }\n\n        target = window;\n      }\n      else if (target.nodeType)\n      {\n        target = qx.dom.Node.getWindow(target);\n      }\n      else if (!qx.dom.Node.isWindow(target))\n      {\n        target = window;\n      }\n\n      var hash = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var manager = this.__managers[hash];\n\n      if (!manager)\n      {\n        manager = new qx.event.Manager(target, this);\n        this.__managers[hash] = manager;\n      }\n\n      return manager;\n    },\n\n\n    /**\n     * Removes a manager for a specific window from the list.\n     *\n     * Normally only used when the manager gets disposed through\n     * an unload event of the attached window.\n     *\n     * @param mgr {qx.event.Manager} The manager to remove\n     */\n    removeManager : function(mgr)\n    {\n      var id = mgr.getWindowId();\n      delete this.__managers[id];\n    },\n\n\n    /**\n     * Add an event listener to a DOM target. The event listener is passed an\n     * instance of {@link qx.event.type.Event} containing all relevant information\n     * about the event as parameter.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\n     * @param listener {Function} Event listener function\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener. When not given, the corresponding dispatcher\n     *         usually falls back to a default, which is the target\n     *         by convention. Note this is not a strict requirement, i.e.\n     *         custom dispatchers can follow a different strategy.\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {var} An opaque id, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     */\n    addListener : function(target, type, listener, self, capture) {\n      return this.getManager(target).addListener(target, type, listener, self, capture);\n    },\n\n\n    /**\n     * Remove an event listener from an event target.\n     *\n     * Note: All registered event listeners will automatically at page unload\n     *   so it is not necessary to detach events in the destructor.\n     *\n     * @param target {Object} The event target\n     * @param type {String} Name of the event\n     * @param listener {Function} The pointer to the event listener\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener.\n     * @param capture {Boolean} Whether to remove the event listener of\n     *    the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\n     *    the event was already removed before.\n     */\n    removeListener : function(target, type, listener, self, capture) {\n      return this.getManager(target).removeListener(target, type, listener, self, capture);\n    },\n\n\n    /**\n     * Removes an event listener from an event target by an id returned by\n     * {@link #addListener}\n     *\n     * @param target {Object} The event target\n     * @param id {var} The id returned by {@link #addListener}\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\n     *    the event was already removed before.\n     */\n    removeListenerById : function(target, id) {\n      return this.getManager(target).removeListenerById(target, id);\n    },\n\n\n    /**\n     * Remove all event listeners, which are attached to the given event target.\n     *\n     * @param target {Object} The event target to remove all event listeners from.\n     * @return {Boolean} Whether the events were existant and were removed successfully.\n     */\n    removeAllListeners : function(target) {\n      return this.getManager(target).removeAllListeners(target);\n    },\n\n\n    /**\n     * Internal helper for deleting the listeners map used during shutdown.\n     *\n     * @param target {Object} The event target to delete the internal map for\n     *    all event listeners.\n     *\n     * @internal\n     */\n    deleteAllListeners : function(target) {\n      var targetKey = target.$$hash;\n      if (targetKey) {\n        this.getManager(target).deleteAllListeners(targetKey);\n      }\n    },\n\n\n    /**\n     * Check whether there are one or more listeners for an event type\n     * registered at the target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} The event type\n     * @param capture {Boolean ? false} Whether to check for listeners of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the target has event listeners of the given type.\n     */\n    hasListener : function(target, type, capture) {\n      return this.getManager(target).hasListener(target, type, capture);\n    },\n\n\n    /**\n     * Returns a serialized array of all events attached on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {Map[]} Array of maps where everyone contains the keys:\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\n     */\n    serializeListeners : function(target) {\n      return this.getManager(target).serializeListeners(target);\n    },\n\n\n    /**\n     * Get an event instance of the given class, which can be dispatched using\n     * an event manager. The created events must be initialized using\n     * {@link qx.event.type.Event#init}.\n     *\n     * @param type {String} The type of the event to create\n     * @param clazz {Object?qx.event.type.Event} The event class to use\n     * @param args {Array?null} Array which will be passed to\n     *       the event's init method.\n     * @return {qx.event.type.Event} An instance of the given class.\n     */\n    createEvent : function(type, clazz, args)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (arguments.length > 1 && clazz === undefined) {\n          throw new Error(\"Create event of type \" + type + \" with undefined class. Please use null to explicit fallback to default event type!\");\n        }\n      }\n\n      // Fallback to default\n      if (clazz == null) {\n        clazz = qx.event.type.Event;\n      }\n\n      var obj = qx.event.Pool.getInstance().getObject(clazz);\n\n      // Initialize with given arguments\n      args ? obj.init.apply(obj, args) : obj.init();\n\n      // Setup the type\n      // Note: Native event may setup this later or using init() above\n      // using the native information.\n      if (type) {\n        obj.setType(type);\n      }\n\n      return obj;\n    },\n\n\n    /**\n     * Dispatch an event object on the given target.\n     *\n     * It is normally better to use {@link #fireEvent} because it uses\n     * the event pooling and is quite handy otherwise as well. After dispatching\n     * the event object will be pooled for later reuse or disposed.\n     *\n     * @param target {Object} Any valid event target\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\n     *       object must be obtained using {@link #createEvent} and initialized\n     *       using {@link qx.event.type.Event#init}.\n     * @return {Boolean} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    dispatchEvent : function(target, event) {\n      return this.getManager(target).dispatchEvent(target, event);\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Event} the event\n     * @see #createEvent\n     */\n    __fireEvent : function(target, type, clazz, args)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\n          throw new Error(\"Create event of type \" + type + \" with undefined class. Please use null to explicit fallback to default event type!\");\n        }\n\n        var msg = \"Could not fire event '\" + type + \"' on target '\" + (target ? target.classname : \"undefined\") +\"': \";\n\n        qx.core.Assert.assertNotUndefined(target, msg + \"Invalid event target.\");\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\n      }\n\n      var evt = this.createEvent(type, clazz||null, args);\n      this.getManager(target).dispatchEvent(target, evt);\n      return evt;\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @see #createEvent\n     */\n    fireEvent : function(target, type, clazz, args)\n    {\n      var evt = this.__fireEvent.apply(this, arguments);\n      return !evt.getDefaultPrevented();\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     * \tif the default was prevented, the promise is rejected\n     * @see #createEvent\n     */\n    fireEventAsync : function(target, type, clazz, args)\n    {\n      var evt = this.__fireEvent.apply(this, arguments);\n      return evt.promise();\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Event} the event\n     * @see #createEvent\n     */\n    __fireNonBubblingEvent : function(target, type, clazz, args)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\n          throw new Error(\"Create event of type \" + type + \" with undefined class. Please use null to explicit fallback to default event type!\");\n        }\n      }\n\n      var mgr = this.getManager(target);\n      if (!mgr.hasListener(target, type, false)) {\n        return null;\n      }\n\n      var evt = this.createEvent(type, clazz||null, args);\n      mgr.dispatchEvent(target, evt);\n      return evt;\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @see #createEvent\n     */\n    fireNonBubblingEvent : function(target, type, clazz, args)\n    {\n      var evt = this.__fireNonBubblingEvent.apply(this, arguments);\n      if (evt === null) {\n      \treturn true;\n      }\n      return !evt.getDefaultPrevented();\n    },\n\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     * \tif the default was prevented, the promise is rejected\n     * @see #createEvent\n     */\n    fireNonBubblingEventAsync : qx.core.Environment.select(\"qx.promise\", {\n      \"true\": function(target, type, clazz, args) {\n        var evt = this.__fireNonBubblingEvent.apply(this, arguments);\n        if (evt === null) {\n          return qx.Promise.resolve(true);\n        }\n        return evt.promise();\n      },\n      \"false\": function() {\n        throw new Error(this.classname + \".fireNonBubblingEventAsync not supported because qx.promise==false\");\n      }\n    }),\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER/DISPATCHER PRIORITY\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Integer} Highest priority. Used by handlers and dispatchers. */\n    PRIORITY_FIRST : -32000,\n\n    /** @type {Integer} Default priority. Used by handlers and dispatchers. */\n    PRIORITY_NORMAL : 0,\n\n    /** @type {Integer} Lowest priority. Used by handlers and dispatchers. */\n    PRIORITY_LAST : 32000,\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER REGISTRATION\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Array} Contains all known event handlers */\n    __handlers : [],\n\n\n    /**\n     * Register an event handler.\n     *\n     * @param handler {qx.event.IEventHandler} Event handler to add\n     * @throws {Error} if the handler does not have the IEventHandler interface.\n     */\n    addHandler : function(handler)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertInterface(handler, qx.event.IEventHandler, \"Invalid event handler.\");\n      }\n\n      // Append to list\n      this.__handlers.push(handler);\n\n      // Re-sort list\n      this.__handlers.sort(function(a, b) {\n        return a.PRIORITY - b.PRIORITY;\n      });\n    },\n\n\n    /**\n     * Get a list of registered event handlers.\n     *\n     * @return {qx.event.IEventHandler[]} registered event handlers\n     */\n    getHandlers : function() {\n      return this.__handlers;\n    },\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT DISPATCHER REGISTRATION\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Array} Contains all known event dispatchers */\n    __dispatchers : [],\n\n\n    /**\n     * Register an event dispatcher.\n     *\n     * @param dispatcher {qx.event.IEventDispatcher} Event dispatcher to add\n     * @param priority {Integer} One of\n     * {@link qx.event.Registration#PRIORITY_FIRST},\n     * {@link qx.event.Registration#PRIORITY_NORMAL}\n     *       or {@link qx.event.Registration#PRIORITY_LAST}.\n     * @throws {Error} if the dispatcher does not have the IEventHandler interface.\n     */\n    addDispatcher : function(dispatcher, priority)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertInterface(dispatcher, qx.event.IEventDispatcher, \"Invalid event dispatcher!\");\n      }\n\n      // Append to list\n      this.__dispatchers.push(dispatcher);\n\n      // Re-sort list\n      this.__dispatchers.sort(function(a, b) {\n        return a.PRIORITY - b.PRIORITY;\n      });\n    },\n\n\n    /**\n     * Get a list of registered event dispatchers.\n     *\n     * @return {qx.event.IEventDispatcher[]} all registered event dispatcher\n     */\n    getDispatchers : function() {\n      return this.__dispatchers;\n    }\n  }\n});\n"
  ]
}